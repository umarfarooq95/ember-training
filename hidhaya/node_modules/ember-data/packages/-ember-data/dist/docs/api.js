YUI.add("yuidoc-meta", function(Y) {
   Y.YUIDoc = { meta: {
    "classes": [
        "@ember-data",
        "@ember-data/model",
        "AbortError",
        "Adapter",
        "AdapterError",
        "AdapterPopulatedRecordArray",
        "BelongsToReference",
        "BooleanTransform",
        "BuildURLMixin",
        "ConflictError",
        "DateTransform",
        "EmbeddedRecordsMixin",
        "Ember.HTMLBars.helpers",
        "Ember.Inflector",
        "Errors",
        "ForbiddenError",
        "HasManyReference",
        "IdentityMap",
        "InspectorDataAdapter",
        "InternalModelMap",
        "InvalidError",
        "JSONAPIAdapter",
        "JSONAPISerializer",
        "JSONSerializer",
        "ManyArray",
        "MinimumSerializerInterface",
        "Model",
        "NotFoundError",
        "NumberTransform",
        "RESTAdapter",
        "RESTSerializer",
        "RecordArray",
        "RecordArrayManager",
        "RecordReference",
        "Reference",
        "RootState",
        "Serializer",
        "ServerError",
        "Snapshot",
        "SnapshotRecordArray",
        "Store",
        "String",
        "StringTransform",
        "TimeoutError",
        "Transform",
        "UnauthorizedError"
    ],
    "modules": [
        "@ember-data",
        "@ember-data_adapter",
        "@ember-data_debug",
        "@ember-data_model",
        "@ember-data_record-data",
        "@ember-data_serializer",
        "@ember-data_store"
    ],
    "allModules": [
        {
            "displayName": "@ember-data",
            "name": "@ember-data"
        },
        {
            "displayName": "@ember-data/adapter",
            "name": "@ember-data_adapter"
        },
        {
            "displayName": "@ember-data/debug",
            "name": "@ember-data_debug",
            "description": "# Overview\n\nThis package provides the `DataAdapter` which the [Ember Inspector](https://github.com/emberjs/ember-inspector)\nuses to subscribe and retrieve information for the `data` tab in the inspector.\n\nThis package adds roughly .6 KB when minified and compressed to your application in production; however,\nyou can opt out of shipping this addon in production via options in `ember-cli-build.js`\n\n```js\nlet app = new EmberApp(defaults, {\n  emberData: {\n    includeDataAdapterInProduction: false\n  }\n});\n```\n\nWhen using `ember-data` as a dependency of your app, the default is to ship the inspector support to production.\n\nWhen not using `ember-data` as a dependency but instead using EmberData via declaring specific `@ember-data/<package>`\ndependencies the default is to not ship to production."
        },
        {
            "displayName": "@ember-data/model",
            "name": "@ember-data_model",
            "description": "In EmberData a `Model` is a class defining the attributes and relationships\n of a specific resource `type` (model name). In this sense it represents a static \"schema\".\n\n Data for individual resources fetched from your API is presented\n to the UI via instances of the `Model`s you define.\n\n An instantiated `Model` is refered to as a `record`.\n\n When we refer to the `ModelClass` we are referring to the class definition\n and the static schema methods present on it.\n\n When we refer to a `record` we refer to a specific class instance presenting\n the resource data for a given `type` and `id`.\n\n ### Defining a Model\n\n ```app/models/person.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default Model.extend({\n   name: attr(),\n\n   dog: belongsTo('pet', { inverse: 'owners', async: false }),\n\n   friends: hasMany('person', { inverse: 'friends', async: true }),\n });\n ```\n\n ### modelName convention\n\n By convention, the name of a given model (its `type`) matches the name\n of the file in the `app/models` folder and should be lowercase, singular\n and dasherized."
        },
        {
            "displayName": "@ember-data/record-data",
            "name": "@ember-data_record-data"
        },
        {
            "displayName": "@ember-data/serializer",
            "name": "@ember-data_serializer",
            "description": "## Overview\n\nIn order to properly manage and present your data, EmberData\nneeds to understand the structure of data it receives.\n\n`Serializers` convert data between the server's API format and\nthe format EmberData understands.\n\nData received from an API response is **normalized** into \n[JSON:API](https://jsonapi.org/) (the format used internally\nby EmberData), while data sent to an API is **serialized**\ninto the format the API expects.\n\n### Implementing a Serializer\n\nThere are only two required serializer methods, one for\nnormalizing data from the server API format into JSON:API, and\nanother for serializing records via `Snapshots` into the expected\nserver API format.\n\nTo implement a serializer, export a class that conforms to the structure\ndescribed by the [MinimumSerializerInterface](/ember-data/release/classes/MinimumSerializerInterface)\nfrom the `app/serializers/` directory. An example is below.\n\n```ts\nimport EmberObject from '@ember/object';\n\nexport default class ApplicationSerializer extends EmberObject {\n  normalizeResponse(store, schema, rawPayload) {\n    return rawPayload;\n  }\n\n  serialize(snapshot, options) {\n    const serializedResource = {\n      id: snapshot.id(),\n      type: snapshot.modelName,\n      attributes: snapshot.attributes()\n    };\n\n    return serializedResource;\n  }\n}\n ```\n\n\n### Serializer Resolution\n\n`store.serializerFor(name)` will lookup serializers defined in\n`app/serializers/` and return an instance. If no serializer is found, an\nerror will be thrown.\n\n`serializerFor` first attempts to find a serializer with an exact match on `name`,\nthen falls back to checking for the presence of a serializer named `application`.\n\n```ts\nstore.serializerFor('author');\n\n// lookup paths (in order) =>\n//   app/serializers/author.js\n//   app/serializers/application.js\n```\n\nMost requests in EmberData are made with respect to a particular `type` (or `modelName`)\n(e.g., \"get me the full collection of **books**\" or \"get me the **employee** whose id is 37\"). We\nrefer to this as the **primary** resource `type`.\n\nTypically `serializerFor` will be used to find a serializer with a name matching that of the primary\nresource `type` for the request, falling back to the `application` serializer for those types that\ndo not have a defined serializer. This is often described as a `per-model` or `per-type` strategy\nfor defining serializers. However, because APIs rarely format payloads per-type but rather\nper-API-version, this may not be a desired strategy.\n\nIt is recommended that applications define only a single `application` adapter and serializer\nwhere possible.\n\nIf you have multiple API formats and the per-type strategy is not viable, one strategy is to\nwrite an `application` adapter and serializer that make use of `options` to specify the desired\nformat when making a request.\n\n### Using a Serializer\n\nAny serializer in `app/serializers/` can be looked up by `name` using `store.serializerFor(name)`.\n\n### Default Serializers\n\nFor applications whose APIs are *very close to* or *exactly* the **REST** format or **JSON:API**\nformat the `@ember-data/serializer` package contains implementations these applications can\nextend. It also contains a simple `JSONSerializer` for serializing to/from very basic JSON objects.\n\nMany applications will find writing their own serializer to be more performant and less\ncomplex than extending these classes even when their API format is very close to that expected\nby these serializers.\n\nIt is recommended that apps write their own serializer to best suit the needs of their API and\napplication."
        },
        {
            "displayName": "@ember-data/store",
            "name": "@ember-data_store",
            "description": "The store service contains all of the data for records loaded from the server.\nIt is also responsible for creating instances of `Model` that wrap\nthe individual data for a record, so that they can be bound to in your\nHandlebars templates.\n\nBy default, applications will have a single `Store` service that is\nautomatically created.\n\nThe store can be customized by extending the service in the following manner:\n\n```app/services/store.js\nimport Store from '@ember-data/store';\n\nexport default class MyStore extends Store {}\n```\n\nYou can retrieve models from the store in several ways. To retrieve a record\nfor a specific id, use the `Store`'s `findRecord()` method:\n\n```javascript\nstore.findRecord('person', 123).then(function (person) {\n});\n```\n\nBy default, the store will talk to your backend using a standard\nREST mechanism. You can customize how the store talks to your\nbackend by specifying a custom adapter:\n\n```app/adapters/application.js\nimport DS from 'ember-data';\n\nexport default Adapter.extend({\n});\n```\n\nYou can learn more about writing a custom adapter by reading the `Adapter`\ndocumentation.\n\n### Store createRecord() vs. push() vs. pushPayload()\n\nThe store provides multiple ways to create new record objects. They have\nsome subtle differences in their use which are detailed below:\n\n[createRecord](Store/methods/createRecord?anchor=createRecord) is used for creating new\nrecords on the client side. This will return a new record in the\n`created.uncommitted` state. In order to persist this record to the\nbackend, you will need to call `record.save()`.\n\n[push](Store/methods/push?anchor=push) is used to notify Ember Data's store of new or\nupdated records that exist in the backend. This will return a record\nin the `loaded.saved` state. The primary use-case for `store#push` is\nto notify Ember Data about record updates (full or partial) that happen\noutside of the normal adapter methods (for example\n[SSE](http://dev.w3.org/html5/eventsource/) or [Web\nSockets](http://www.w3.org/TR/2009/WD-websockets-20091222/)).\n\n[pushPayload](Store/methods/pushPayload?anchor=pushPayload) is a convenience wrapper for\n`store#push` that will deserialize payloads if the\nSerializer implements a `pushPayload` method.\n\nNote: When creating a new record using any of the above methods\nEmber Data will update `RecordArray`s such as those returned by\n`store#peekAll()` or `store#findAll()`. This means any\ndata bindings or computed properties that depend on the RecordArray\nwill automatically be synced to include the new or updated record\nvalues."
        }
    ],
    "elements": []
} };
});