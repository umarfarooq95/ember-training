<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../store/addon/-private/identifiers/cache.ts - The ember-data API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The ember-data API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v3.16.0-alpha.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/@ember-data.html">@ember-data</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/AdapterPopulatedRecordArray.html">AdapterPopulatedRecordArray</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Ember.HTMLBars.helpers.html">Ember.HTMLBars.helpers</a></li>
                                <li><a href="../classes/Ember.Inflector.html">Ember.Inflector</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentityMap.html">IdentityMap</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InternalModelMap.html">InternalModelMap</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/MinimumSerializerInterface.html">MinimumSerializerInterface</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordArrayManager.html">RecordArrayManager</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/Reference.html">Reference</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/RootState.html">RootState</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data.html">@ember-data</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_record-data.html">@ember-data/record-data</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../store/addon/-private/identifiers/cache.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { DEBUG } from &#x27;@glimmer/env&#x27;;
import { warn } from &#x27;@ember/debug&#x27;;
import { ConfidentDict } from &#x27;../ts-interfaces/utils&#x27;;
import { ResourceIdentifierObject, ExistingResourceObject } from &#x27;../ts-interfaces/ember-data-json-api&#x27;;
import {
  StableRecordIdentifier,
  DEBUG_CLIENT_ORIGINATED,
  DEBUG_IDENTIFIER_BUCKET,
  GenerationMethod,
  UpdateMethod,
  ForgetMethod,
  ResetMethod,
  RecordIdentifier,
} from &#x27;../ts-interfaces/identifier&#x27;;
import coerceId from &#x27;../system/coerce-id&#x27;;
import uuidv4 from &#x27;./utils/uuid-v4&#x27;;
import normalizeModelName from &#x27;../system/normalize-model-name&#x27;;
import isStableIdentifier, { markStableIdentifier, unmarkStableIdentifier } from &#x27;./is-stable-identifier&#x27;;
import isNonEmptyString from &#x27;../utils/is-non-empty-string&#x27;;
import CoreStore from &#x27;../system/core-store&#x27;;

/**
  @module @ember-data/store
*/

interface KeyOptions {
  lid: IdentifierMap;
  id: IdentifierMap;
  _allIdentifiers: StableRecordIdentifier[];
}

type IdentifierMap = ConfidentDict&lt;StableRecordIdentifier&gt;;
type TypeMap = ConfidentDict&lt;KeyOptions&gt;;
export type MergeMethod = (
  targetIdentifier: StableRecordIdentifier,
  matchedIdentifier: StableRecordIdentifier,
  resourceData: ResourceIdentifierObject | ExistingResourceObject
) =&gt; StableRecordIdentifier;

let configuredForgetMethod: ForgetMethod | null;
let configuredGenerationMethod: GenerationMethod | null;
let configuredResetMethod: ResetMethod | null;
let configuredUpdateMethod: UpdateMethod | null;

export function setIdentifierGenerationMethod(method: GenerationMethod | null): void {
  configuredGenerationMethod = method;
}

export function setIdentifierUpdateMethod(method: UpdateMethod | null): void {
  configuredUpdateMethod = method;
}

export function setIdentifierForgetMethod(method: ForgetMethod | null): void {
  configuredForgetMethod = method;
}

export function setIdentifierResetMethod(method: ResetMethod | null): void {
  configuredResetMethod = method;
}

function defaultGenerationMethod(data: ResourceIdentifierObject, bucket: string): string {
  if (isNonEmptyString(data.lid)) {
    return data.lid;
  }
  let { type, id } = data;
  if (isNonEmptyString(id)) {
    return &#x60;@ember-data:lid-${normalizeModelName(type)}-${id}&#x60;;
  }
  return uuidv4();
}

const IdentifierCaches = new WeakMap&lt;CoreStore, IdentifierCache&gt;();

export function identifierCacheFor(store: CoreStore): IdentifierCache {
  let cache = IdentifierCaches.get(store);

  if (cache === undefined) {
    cache = new IdentifierCache();
    IdentifierCaches.set(store, cache);
  }

  return cache;
}

function defaultEmptyCallback(...args: any[]): any {}

let DEBUG_MAP;
if (DEBUG) {
  DEBUG_MAP = new WeakMap&lt;StableRecordIdentifier, StableRecordIdentifier&gt;();
}

export class IdentifierCache {
  // Typescript still leaks private properties in the final
  // compiled class, so we may want to move these from _underscore
  // to a WeakMap to avoid leaking
  // currently we leak this for test purposes
  _cache = {
    lids: Object.create(null) as IdentifierMap,
    types: Object.create(null) as TypeMap,
  };
  private _generate: GenerationMethod;
  private _update: UpdateMethod;
  private _forget: ForgetMethod;
  private _reset: ResetMethod;
  private _merge: MergeMethod;

  constructor() {
    // we cache the user configuredGenerationMethod at init because it must
    // be configured prior and is not allowed to be changed
    this._generate = configuredGenerationMethod || defaultGenerationMethod;
    this._update = configuredUpdateMethod || defaultEmptyCallback;
    this._forget = configuredForgetMethod || defaultEmptyCallback;
    this._reset = configuredResetMethod || defaultEmptyCallback;
    this._merge = defaultEmptyCallback;
  }

  /**
   * hook to allow management of merge conflicts with identifiers.
   *
   * we allow late binding of this private internal merge so that &#x60;internalModelFactory&#x60;
   * can insert itself here to handle elimination of duplicates
   *
   * @internal
   */
  __configureMerge(method: MergeMethod | null) {
    this._merge = method || defaultEmptyCallback;
  }

  /**
   * @internal
   */
  private _getRecordIdentifier(resource: ResourceIdentifierObject, shouldGenerate: true): StableRecordIdentifier;
  private _getRecordIdentifier(
    resource: ResourceIdentifierObject,
    shouldGenerate: false
  ): StableRecordIdentifier | undefined;
  private _getRecordIdentifier(
    resource: ResourceIdentifierObject,
    shouldGenerate: boolean = false
  ): StableRecordIdentifier | undefined {
    // short circuit if we&#x27;re already the stable version
    if (isStableIdentifier(resource)) {
      if (DEBUG) {
        // TODO should we instead just treat this case as a new generation skipping the short circuit?
        if (!(resource.lid in this._cache.lids) || this._cache.lids[resource.lid] !== resource) {
          throw new Error(&#x60;The supplied identifier ${resource} does not belong to this store instance&#x60;);
        }
      }
      return resource;
    }

    // &#x60;type&#x60; must always be present
    if (DEBUG) {
      if (!isNonEmptyString(resource.type)) {
        throw new Error(&#x27;resource.type needs to be a string&#x27;);
      }
    }

    let type = normalizeModelName(resource.type);
    let keyOptions = getTypeIndex(this._cache.types, type);
    let identifier: StableRecordIdentifier | undefined;
    let lid = coerceId(resource.lid);
    let id = coerceId(resource.id);

    // go straight for the stable RecordIdentifier key&#x27;d to &#x60;lid&#x60;
    if (lid !== null) {
      identifier = keyOptions.lid[lid];
    }

    // we may have not seen this resource before
    // but just in case we check our own secondary lookup (&#x60;id&#x60;)
    if (identifier === undefined &amp;&amp; id !== null) {
      identifier = keyOptions.id[id];
    }

    if (identifier === undefined) {
      // we have definitely not seen this resource before
      // so we allow the user configured &#x60;GenerationMethod&#x60; to tell us
      let newLid = this._generate(resource, &#x27;record&#x27;);

      // we do this _even_ when &#x60;lid&#x60; is present because secondary lookups
      // may need to be populated, but we enforce not giving us something
      // different than expected
      if (lid !== null &amp;&amp; newLid !== lid) {
        throw new Error(&#x60;You should not change the &lt;lid&gt; of a RecordIdentifier&#x60;);
      } else if (lid === null) {
        // allow configuration to tell us that we have
        // seen this &#x60;lid&#x60; before. E.g. a secondary lookup
        // connects this resource to a previously seen
        // resource.
        identifier = keyOptions.lid[newLid];
      }

      if (shouldGenerate === true) {
        if (identifier === undefined) {
          // if we still don&#x27;t have an identifier, time to generate one
          identifier = makeStableRecordIdentifier(id, type, newLid, &#x27;record&#x27;, false);

          // populate our unique table
          if (DEBUG) {
            // realistically if you hit this it means you changed &#x60;type&#x60; :/
            // TODO consider how to handle type change assertions more gracefully
            if (identifier.lid in this._cache.lids) {
              throw new Error(&#x60;You should not change the &lt;type&gt; of a RecordIdentifier&#x60;);
            }
          }
          this._cache.lids[identifier.lid] = identifier;

          // populate our primary lookup table
          // TODO consider having the &#x60;lid&#x60; cache be
          // one level up
          keyOptions.lid[identifier.lid] = identifier;
          // TODO exists temporarily to support &#x60;peekAll&#x60;
          // but likely to move
          keyOptions._allIdentifiers.push(identifier);
        }

        // populate our own secondary lookup table
        // even for the &quot;successful&quot; secondary lookup
        // by &#x60;_generate()&#x60;, since we missed the cache
        // previously
        // we use identifier.id instead of id here
        // because they may not match and we prefer
        // what we&#x27;ve set via resource data
        if (identifier.id !== null) {
          keyOptions.id[identifier.id] = identifier;

          // TODO allow filling out of &#x60;id&#x60; here
          // for the &#x60;username&#x60; non-client created
          // case.
        }
      }
    }

    return identifier;
  }

  /**
   * allows us to peek without generating when needed
   * useful for the &quot;create&quot; case when we need to see if
   * we are accidentally overwritting something
   *
   * @internal
   */
  peekRecordIdentifier(resource: ResourceIdentifierObject): StableRecordIdentifier | undefined {
    return this._getRecordIdentifier(resource, false);
  }

  /*
    Returns the Identifier for the given Resource, creates one if it does not yet exist.

    Specifically this means that we:

    - validate the &#x60;id&#x60; &#x60;type&#x60; and &#x60;lid&#x60; combo against known identifiers
    - return an object with an &#x60;lid&#x60; that is stable (repeated calls with the same
      &#x60;id&#x60; + &#x60;type&#x60; or &#x60;lid&#x60; will return the same &#x60;lid&#x60; value)
    - this referential stability of the object itself is guaranteed
  */
  getOrCreateRecordIdentifier(resource: ResourceIdentifierObject | ExistingResourceObject): StableRecordIdentifier {
    return this._getRecordIdentifier(resource, true);
  }

  /*
   Returns a new Identifier for the supplied data. Call this method to generate
   an identifier when a new resource is being created local to the client and
   potentially does not have an &#x60;id&#x60;.

   Delegates generation to the user supplied &#x60;GenerateMethod&#x60; if one has been provided
   with the signature &#x60;generateMethod({ type }, &#x27;record&#x27;)&#x60;.

  */
  createIdentifierForNewRecord(data: { type: string; id?: string | null }): StableRecordIdentifier {
    let newLid = this._generate(data, &#x27;record&#x27;);
    let identifier = makeStableRecordIdentifier(data.id || null, data.type, newLid, &#x27;record&#x27;, true);
    let keyOptions = getTypeIndex(this._cache.types, data.type);

    // populate our unique table
    if (DEBUG) {
      if (identifier.lid in this._cache.lids) {
        throw new Error(&#x60;The lid generated for the new record is not unique as it matches an existing identifier&#x60;);
      }
    }
    this._cache.lids[identifier.lid] = identifier;

    // populate the type+lid cache
    keyOptions.lid[newLid] = identifier;
    // ensure a peekAll sees our new identifier too
    // TODO move this outta here?
    keyOptions._allIdentifiers.push(identifier);

    return identifier;
  }

  /*
   Provides the opportunity to update secondary lookup tables for existing identifiers
   Called after an identifier created with &#x60;createIdentifierForNewRecord&#x60; has been
   committed.

   Assigned &#x60;id&#x60; to an &#x60;Identifier&#x60; if &#x60;id&#x60; has not previously existed; however,
   attempting to change the &#x60;id&#x60; or calling update without providing an &#x60;id&#x60; when
   one is missing will throw an error.

    - sets &#x60;id&#x60; (if &#x60;id&#x60; was previously &#x60;null&#x60;)
    - &#x60;lid&#x60; and &#x60;type&#x60; MUST NOT be altered post creation

    If a merge occurs, it is possible the returned identifier does not match the originally
    provided identifier. In this case the abandoned identifier will go through the usual
    &#x60;forgetRecordIdentifier&#x60; codepaths.
  */
  updateRecordIdentifier(
    identifierObject: RecordIdentifier,
    data: ResourceIdentifierObject | ExistingResourceObject
  ): StableRecordIdentifier {
    let identifier = this.getOrCreateRecordIdentifier(identifierObject);

    let id = identifier.id;
    let newId = coerceId(data.id);

    const keyOptions = getTypeIndex(this._cache.types, identifier.type);
    let existingIdentifier = detectMerge(keyOptions, identifier, newId);

    if (existingIdentifier) {
      identifier = this._mergeRecordIdentifiers(keyOptions, identifier, existingIdentifier, data, newId as string);
    }

    id = identifier.id;
    performRecordIdentifierUpdate(identifier, data, this._update);
    newId = identifier.id;

    // add to our own secondary lookup table
    if (id !== newId &amp;&amp; newId !== null) {
      let keyOptions = getTypeIndex(this._cache.types, identifier.type);
      keyOptions.id[newId] = identifier;

      if (id !== null) {
        delete keyOptions.id[id];
      }
    }

    return identifier;
  }

  _mergeRecordIdentifiers(
    keyOptions: KeyOptions,
    identifier: StableRecordIdentifier,
    existingIdentifier: StableRecordIdentifier,
    data: ResourceIdentifierObject | ExistingResourceObject,
    newId: string
  ): StableRecordIdentifier {
    // delegate determining which identifier to keep to the configured MergeMethod
    let kept = this._merge(identifier, existingIdentifier, data);
    let abandoned = kept === identifier ? existingIdentifier : identifier;

    // cleanup the identifier we no longer need
    this.forgetRecordIdentifier(abandoned);

    // ensure a secondary cache entry for this id for the identifier we do keep
    keyOptions.id[newId] = kept;

    // make sure that the &#x60;lid&#x60; on the data we are processing matches the lid we kept
    data.lid = kept.lid;

    return kept;
  }

  /*
   Provides the opportunity to eliminate an identifier from secondary lookup tables
   as well as eliminates it from ember-data&#x27;s own lookup tables and book keeping.

   Useful when a record has been deleted and the deletion has been persisted and
   we do not care about the record anymore. Especially useful when an &#x60;id&#x60; of a
   deleted record might be reused later for a new record.
  */
  forgetRecordIdentifier(identifierObject: RecordIdentifier): void {
    let identifier = this.getOrCreateRecordIdentifier(identifierObject);
    let keyOptions = getTypeIndex(this._cache.types, identifier.type);
    if (identifier.id !== null) {
      delete keyOptions.id[identifier.id];
    }
    delete this._cache.lids[identifier.lid];
    delete keyOptions.lid[identifier.lid];

    let index = keyOptions._allIdentifiers.indexOf(identifier);
    keyOptions._allIdentifiers.splice(index, 1);

    unmarkStableIdentifier(identifierObject);
    this._forget(identifier, &#x27;record&#x27;);
  }

  destroy() {
    this._reset();
  }
}

function getTypeIndex(typeMap: TypeMap, type: string): KeyOptions {
  let typeIndex: KeyOptions = typeMap[type];

  if (typeIndex === undefined) {
    typeIndex = {
      lid: Object.create(null),
      id: Object.create(null),
      _allIdentifiers: [],
    };
    typeMap[type] = typeIndex;
  }

  return typeIndex;
}

function makeStableRecordIdentifier(
  id: string | null,
  type: string,
  lid: string,
  bucket: string,
  clientOriginated: boolean = false
): Readonly&lt;StableRecordIdentifier&gt; {
  let recordIdentifier = {
    lid,
    id,
    type,
  };
  markStableIdentifier(recordIdentifier);

  if (DEBUG) {
    // we enforce immutability in dev
    //  but preserve our ability to do controlled updates to the reference
    let wrapper = Object.freeze({
      [DEBUG_CLIENT_ORIGINATED]: clientOriginated,
      [DEBUG_IDENTIFIER_BUCKET]: bucket,
      get lid() {
        return recordIdentifier.lid;
      },
      get id() {
        return recordIdentifier.id;
      },
      get type() {
        return recordIdentifier.type;
      },
      toString() {
        let { type, id, lid } = recordIdentifier;
        return &#x60;${clientOriginated ? &#x27;[CLIENT_ORIGINATED] &#x27; : &#x27;&#x27;}${type}:${id} (${lid})&#x60;;
      },
    });
    markStableIdentifier(wrapper);
    DEBUG_MAP.set(wrapper, recordIdentifier);
    return wrapper;
  }

  return recordIdentifier;
}

function performRecordIdentifierUpdate(
  identifier: StableRecordIdentifier,
  data: ResourceIdentifierObject,
  updateFn: UpdateMethod
) {
  let { id, lid } = data;
  let type = normalizeModelName(data.type);

  if (DEBUG) {
    // get the mutable instance behind our proxy wrapper
    let wrapper = identifier;
    identifier = DEBUG_MAP.get(wrapper);

    if (lid !== undefined) {
      let newLid = coerceId(lid);
      if (newLid !== identifier.lid) {
        throw new Error(
          &#x60;The &#x27;lid&#x27; for a RecordIdentifier cannot be updated once it has been created. Attempted to set lid for &#x27;${wrapper}&#x27; to &#x27;${lid}&#x27;.&#x60;
        );
      }
    }

    if (id !== undefined) {
      let newId = coerceId(id);

      if (identifier.id !== null &amp;&amp; identifier.id !== newId) {
        // here we warn and ignore, as this may be a mistake, but we allow the user
        // to have multiple cache-keys pointing at a single lid so we cannot error
        warn(
          &#x60;The &#x27;id&#x27; for a RecordIdentifier should not be updated once it has been set. Attempted to set id for &#x27;${wrapper}&#x27; to &#x27;${newId}&#x27;.&#x60;,
          false,
          { id: &#x27;ember-data:multiple-ids-for-identifier&#x27; }
        );
      }
    }

    // TODO consider just ignoring here to allow flexible polymorphic support
    if (type !== identifier.type) {
      throw new Error(
        &#x60;The &#x27;type&#x27; for a RecordIdentifier cannot be updated once it has been set. Attempted to set type for &#x27;${wrapper}&#x27; to &#x27;${type}&#x27;.&#x60;
      );
    }

    updateFn(wrapper, data, &#x27;record&#x27;);
  } else {
    updateFn(identifier, data, &#x27;record&#x27;);
  }

  // upgrade the ID, this is a &quot;one time only&quot; ability
  // for the multiple-cache-key scenario we &quot;could&quot;
  // use a heuristic to guess the best id for display
  // (usually when &#x60;data.id&#x60; is available and &#x60;data.attributes&#x60; is not)
  if (id !== undefined) {
    identifier.id = coerceId(id);
  }
}

function detectMerge(
  keyOptions: KeyOptions,
  identifier: StableRecordIdentifier,
  newId: string | null
): StableRecordIdentifier | false {
  const { id } = identifier;
  if (id !== null &amp;&amp; id !== newId &amp;&amp; newId !== null) {
    const existingIdentifier = keyOptions.id[newId];

    return existingIdentifier !== undefined ? existingIdentifier : false;
  }

  return false;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
