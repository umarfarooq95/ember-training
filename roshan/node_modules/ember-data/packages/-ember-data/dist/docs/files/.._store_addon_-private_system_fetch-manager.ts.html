<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../store/addon/-private/system/fetch-manager.ts - The ember-data API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The ember-data API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v3.16.0-alpha.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/@ember-data.html">@ember-data</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/AdapterPopulatedRecordArray.html">AdapterPopulatedRecordArray</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Ember.HTMLBars.helpers.html">Ember.HTMLBars.helpers</a></li>
                                <li><a href="../classes/Ember.Inflector.html">Ember.Inflector</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentityMap.html">IdentityMap</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InternalModelMap.html">InternalModelMap</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/MinimumSerializerInterface.html">MinimumSerializerInterface</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordArrayManager.html">RecordArrayManager</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/Reference.html">Reference</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/RootState.html">RootState</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data.html">@ember-data</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_record-data.html">@ember-data/record-data</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../store/addon/-private/system/fetch-manager.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { default as RSVP, Promise } from &#x27;rsvp&#x27;;
import { DEBUG } from &#x27;@glimmer/env&#x27;;
import { run as emberRunLoop } from &#x27;@ember/runloop&#x27;;
import { assert, warn } from &#x27;@ember/debug&#x27;;
import Snapshot from &#x27;./snapshot&#x27;;
import { guardDestroyedStore, _guard, _bind, _objectIsAlive } from &#x27;./store/common&#x27;;
import { normalizeResponseHelper } from &#x27;./store/serializer-response&#x27;;
import coerceId from &#x27;./coerce-id&#x27;;
import { A } from &#x27;@ember/array&#x27;;
import RequestCache from &#x27;./request-cache&#x27;;
import { CollectionResourceDocument, SingleResourceDocument } from &#x27;../ts-interfaces/ember-data-json-api&#x27;;
import { RecordIdentifier } from &#x27;../ts-interfaces/identifier&#x27;;
import { FindRecordQuery, SaveRecordMutation, Request } from &#x27;../ts-interfaces/fetch-manager&#x27;;
import { symbol } from &#x27;../ts-interfaces/utils/symbol&#x27;;
import CoreStore from &#x27;./core-store&#x27;;
import { errorsArrayToHash } from &#x27;./errors-utils&#x27;;

function payloadIsNotBlank(adapterPayload): boolean {
  if (Array.isArray(adapterPayload)) {
    return true;
  } else {
    return Object.keys(adapterPayload || {}).length !== 0;
  }
}

const emberRun = emberRunLoop.backburner;
export const SaveOp: unique symbol = symbol(&#x27;SaveOp&#x27;);

interface PendingFetchItem {
  identifier: RecordIdentifier;
  queryRequest: Request;
  resolver: RSVP.Deferred&lt;any&gt;;
  options: { [k: string]: unknown };
  trace?: any;
}

interface PendingSaveItem {
  resolver: RSVP.Deferred&lt;any&gt;;
  snapshot: Snapshot;
  identifier: RecordIdentifier;
  options: { [k: string]: unknown; [SaveOp]: &#x27;createRecord&#x27; | &#x27;saveRecord&#x27; | &#x27;updateRecord&#x27; };
  queryRequest: Request;
}

export default class FetchManager {
  isDestroyed: boolean;
  requestCache: RequestCache;
  // saves which are pending in the runloop
  _pendingSave: PendingSaveItem[];
  // fetches pending in the runloop, waiting to be coalesced
  _pendingFetch: Map&lt;string, PendingFetchItem[]&gt;;

  constructor(private _store: CoreStore) {
    // used to keep track of all the find requests that need to be coalesced
    this._pendingFetch = new Map();
    this._pendingSave = [];
    this.requestCache = new RequestCache();
  }

  /**
    This method is called by &#x60;record.save&#x60;, and gets passed a
    resolver for the promise that &#x60;record.save&#x60; returns.

    It schedules saving to happen at the end of the run loop.
 */
  scheduleSave(identifier: RecordIdentifier, options: any = {}): RSVP.Promise&lt;null | SingleResourceDocument&gt; {
    let promiseLabel = &#x27;DS: Model#save &#x27; + this;
    let resolver = RSVP.defer&lt;null | SingleResourceDocument&gt;(promiseLabel);
    let query: SaveRecordMutation = {
      op: &#x27;saveRecord&#x27;,
      recordIdentifier: identifier,
      options,
    };

    let queryRequest: Request = {
      data: [query],
    };

    let snapshot = new Snapshot(options, identifier, this._store);
    let pendingSaveItem = {
      snapshot: snapshot,
      resolver: resolver,
      identifier,
      options,
      queryRequest,
    };
    this._pendingSave.push(pendingSaveItem);
    emberRun.scheduleOnce(&#x27;actions&#x27;, this, this._flushPendingSaves);

    this.requestCache.enqueue(resolver.promise, pendingSaveItem.queryRequest);

    return resolver.promise;
  }

  _flushPendingSave(pending: PendingSaveItem) {
    let { snapshot, resolver, identifier, options } = pending;
    let adapter = this._store.adapterFor(identifier.type);
    let operation = options[SaveOp];

    let internalModel = snapshot._internalModel;
    let modelName = snapshot.modelName;
    let store = this._store;
    let modelClass = store.modelFor(modelName);

    assert(&#x60;You tried to update a record but you have no adapter (for ${modelName})&#x60;, adapter);
    assert(
      &#x60;You tried to update a record but your adapter (for ${modelName}) does not implement &#x27;${operation}&#x27;&#x60;,
      typeof adapter[operation] === &#x27;function&#x27;
    );

    let promise = Promise.resolve().then(() =&gt; adapter[operation](store, modelClass, snapshot));
    let serializer = store.serializerFor(modelName);
    let label = &#x60;DS: Extract and notify about ${operation} completion of ${internalModel}&#x60;;

    assert(
      &#x60;Your adapter&#x27;s &#x27;${operation}&#x27; method must return a value, but it returned &#x27;undefined&#x27;&#x60;,
      promise !== undefined
    );

    promise = guardDestroyedStore(promise, store, label);
    promise = _guard(promise, _bind(_objectIsAlive, internalModel));

    promise = promise.then(
      adapterPayload =&gt; {
        if (adapterPayload) {
          return normalizeResponseHelper(serializer, store, modelClass, adapterPayload, snapshot.id, operation);
        }
      },
      function(error) {
        if (error &amp;&amp; error.isAdapterError === true &amp;&amp; error.code === &#x27;InvalidError&#x27;) {
          let parsedErrors = error.errors;

          if (typeof serializer.extractErrors === &#x27;function&#x27;) {
            parsedErrors = serializer.extractErrors(store, modelClass, error, snapshot.id);
          } else {
            parsedErrors = errorsArrayToHash(error.errors);
          }

          throw { error, parsedErrors };
        } else {
          throw { error };
        }
      },
      label
    );
    resolver.resolve(promise);
  }

  /**
    This method is called at the end of the run loop, and
    flushes any records passed into &#x60;scheduleSave&#x60;

    @method flushPendingSave
    @private
  */
  _flushPendingSaves() {
    let pending = this._pendingSave.slice();
    this._pendingSave = [];
    for (let i = 0, j = pending.length; i &lt; j; i++) {
      let pendingItem = pending[i];
      this._flushPendingSave(pendingItem);
    }
  }

  scheduleFetch(identifier: RecordIdentifier, options: any, shouldTrace: boolean): RSVP.Promise&lt;any&gt; {
    // TODO Probably the store should pass in the query object

    let query: FindRecordQuery = {
      op: &#x27;findRecord&#x27;,
      recordIdentifier: identifier,
      options,
    };

    let queryRequest: Request = {
      data: [query],
    };

    let pendingFetches = this._pendingFetch.get(identifier.type);

    // We already have a pending fetch for this
    if (pendingFetches) {
      let matchingPendingFetch = pendingFetches.find(fetch =&gt; fetch.identifier.id === identifier.id);
      if (matchingPendingFetch) {
        return matchingPendingFetch.resolver.promise;
      }
    }

    let id = identifier.id;
    let modelName = identifier.type;

    let resolver = RSVP.defer(&#x60;Fetching ${modelName}&#x27; with id: ${id}&#x60;);
    let pendingFetchItem: PendingFetchItem = {
      identifier,
      resolver,
      options,
      queryRequest,
    };

    if (DEBUG) {
      if (shouldTrace) {
        let trace;

        try {
          throw new Error(&#x60;Trace Origin for scheduled fetch for ${modelName}:${id}.&#x60;);
        } catch (e) {
          trace = e;
        }

        // enable folks to discover the origin of this findRecord call when
        // debugging. Ideally we would have a tracked queue for requests with
        // labels or local IDs that could be used to merge this trace with
        // the trace made available when we detect an async leak
        pendingFetchItem.trace = trace;
      }
    }

    let promise = resolver.promise;

    if (this._pendingFetch.size === 0) {
      emberRun.schedule(&#x27;actions&#x27;, this, this.flushAllPendingFetches);
    }

    let fetches = this._pendingFetch;

    if (!fetches.has(modelName)) {
      fetches.set(modelName, []);
    }

    (fetches.get(modelName) as PendingFetchItem[]).push(pendingFetchItem);

    this.requestCache.enqueue(promise, pendingFetchItem.queryRequest);
    return promise;
  }

  _fetchRecord(fetchItem: PendingFetchItem) {
    let identifier = fetchItem.identifier;
    let modelName = identifier.type;
    let adapter = this._store.adapterFor(modelName);

    assert(&#x60;You tried to find a record but you have no adapter (for ${modelName})&#x60;, adapter);
    assert(
      &#x60;You tried to find a record but your adapter (for ${modelName}) does not implement &#x27;findRecord&#x27;&#x60;,
      typeof adapter.findRecord === &#x27;function&#x27;
    );

    let snapshot = new Snapshot(fetchItem.options, identifier, this._store);
    let klass = this._store.modelFor(identifier.type);

    let promise = Promise.resolve().then(() =&gt; {
      return adapter.findRecord(this._store, klass, identifier.id, snapshot);
    });

    let id = identifier.id;

    let label = &#x60;DS: Handle Adapter#findRecord of &#x27;${modelName}&#x27; with id: &#x27;${id}&#x27;&#x60;;

    promise = guardDestroyedStore(promise, this._store, label);
    promise = promise.then(
      adapterPayload =&gt; {
        assert(
          &#x60;You made a &#x27;findRecord&#x27; request for a &#x27;${modelName}&#x27; with id &#x27;${id}&#x27;, but the adapter&#x27;s response did not have any data&#x60;,
          !!payloadIsNotBlank(adapterPayload)
        );
        let serializer = this._store.serializerFor(modelName);
        let payload = normalizeResponseHelper(serializer, this._store, klass, adapterPayload, id, &#x27;findRecord&#x27;);
        assert(
          &#x60;Ember Data expected the primary data returned from a &#x27;findRecord&#x27; response to be an object but instead it found an array.&#x60;,
          !Array.isArray(payload.data)
        );

        warn(
          &#x60;You requested a record of type &#x27;${modelName}&#x27; with id &#x27;${id}&#x27; but the adapter returned a payload with primary data having an id of &#x27;${payload.data.id}&#x27;. Use &#x27;store.findRecord()&#x27; when the requested id is the same as the one returned by the adapter. In other cases use &#x27;store.queryRecord()&#x27; instead.&#x60;,
          coerceId(payload.data.id) === coerceId(id),
          {
            id: &#x27;ds.store.findRecord.id-mismatch&#x27;,
          }
        );

        return payload;
      },
      error =&gt; {
        throw error;
      },
      &#x60;DS: Extract payload of &#x27;${modelName}&#x27;&#x60;
    );

    fetchItem.resolver.resolve(promise);
  }

  // TODO should probably refactor expectedSnapshots to be identifiers
  handleFoundRecords(
    seeking: { [id: string]: PendingFetchItem },
    coalescedPayload: CollectionResourceDocument,
    expectedSnapshots: Snapshot[]
  ) {
    // resolve found records
    let found = Object.create(null);
    let payloads = coalescedPayload.data;
    let coalescedIncluded = coalescedPayload.included || [];
    for (let i = 0, l = payloads.length; i &lt; l; i++) {
      let payload = payloads[i];
      let pair = seeking[payload.id];
      found[payload.id] = payload;
      let included = coalescedIncluded.concat(payloads);

      // TODO remove original data from included
      if (pair) {
        let resolver = pair.resolver;
        resolver.resolve({ data: payload, included });
      }
    }

    // reject missing records

    // TODO NOW clean this up to refer to payloads
    let missingSnapshots: Snapshot[] = [];

    for (let i = 0, l = expectedSnapshots.length; i &lt; l; i++) {
      let snapshot = expectedSnapshots[i];

      if (!found[snapshot.id]) {
        missingSnapshots.push(snapshot);
      }
    }

    if (missingSnapshots.length) {
      warn(
        &#x27;Ember Data expected to find records with the following ids in the adapter response but they were missing: [ &quot;&#x27; +
          missingSnapshots.map(r =&gt; r.id).join(&#x27;&quot;, &quot;&#x27;) +
          &#x27;&quot; ]&#x27;,
        false,
        {
          id: &#x27;ds.store.missing-records-from-adapter&#x27;,
        }
      );
      this.rejectFetchedItems(seeking, missingSnapshots);
    }
  }

  rejectFetchedItems(seeking: { [id: string]: PendingFetchItem }, snapshots: Snapshot[], error?) {
    for (let i = 0, l = snapshots.length; i &lt; l; i++) {
      let identifier = snapshots[i];
      let pair = seeking[identifier.id];

      if (pair) {
        pair.resolver.reject(
          error ||
            new Error(
              &#x60;Expected: &#x27;&lt;${identifier.modelName}:${identifier.id}&gt;&#x27; to be present in the adapter provided payload, but it was not found.&#x60;
            )
        );
      }
    }
  }

  _findMany(
    adapter: any,
    store: CoreStore,
    modelName: string,
    snapshots: Snapshot[],
    identifiers: RecordIdentifier[],
    optionsMap
  ) {
    let modelClass = store.modelFor(modelName); // &#x60;adapter.findMany&#x60; gets the modelClass still
    let ids = snapshots.map(s =&gt; s.id);
    let promise = adapter.findMany(store, modelClass, ids, A(snapshots));
    let label = &#x60;DS: Handle Adapter#findMany of &#x27;${modelName}&#x27;&#x60;;

    if (promise === undefined) {
      throw new Error(&#x27;adapter.findMany returned undefined, this was very likely a mistake&#x27;);
    }

    promise = guardDestroyedStore(promise, store, label);

    return promise.then(
      adapterPayload =&gt; {
        assert(
          &#x60;You made a &#x27;findMany&#x27; request for &#x27;${modelName}&#x27; records with ids &#x27;[${ids}]&#x27;, but the adapter&#x27;s response did not have any data&#x60;,
          !!payloadIsNotBlank(adapterPayload)
        );
        let serializer = store.serializerFor(modelName);
        let payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, &#x27;findMany&#x27;);
        return payload;
      },
      null,
      &#x60;DS: Extract payload of ${modelName}&#x60;
    );
  }

  _processCoalescedGroup(
    seeking: { [id: string]: PendingFetchItem },
    group: Snapshot[],
    adapter: any,
    optionsMap,
    modelName: string
  ) {
    //TODO check what happened with identifiers here
    let totalInGroup = group.length;
    let ids = new Array(totalInGroup);
    let groupedSnapshots = new Array(totalInGroup);

    for (let j = 0; j &lt; totalInGroup; j++) {
      groupedSnapshots[j] = group[j];
      ids[j] = groupedSnapshots[j].id;
    }

    let store = this._store;
    if (totalInGroup &gt; 1) {
      this._findMany(adapter, store, modelName, group, groupedSnapshots, optionsMap)
        .then(payloads =&gt; {
          this.handleFoundRecords(seeking, payloads, groupedSnapshots);
        })
        .catch(error =&gt; {
          this.rejectFetchedItems(seeking, groupedSnapshots, error);
        });
    } else if (ids.length === 1) {
      let pair = seeking[groupedSnapshots[0].id];
      this._fetchRecord(pair);
    } else {
      assert(&quot;You cannot return an empty array from adapter&#x27;s method groupRecordsForFindMany&quot;, false);
    }
  }

  _flushPendingFetchForType(pendingFetchItems: PendingFetchItem[], modelName: string) {
    let adapter = this._store.adapterFor(modelName);
    let shouldCoalesce = !!adapter.findMany &amp;&amp; adapter.coalesceFindRequests;
    let totalItems = pendingFetchItems.length;
    let identifiers = new Array(totalItems);
    let seeking: { [id: string]: PendingFetchItem } = Object.create(null);

    let optionsMap = new WeakMap&lt;RecordIdentifier, Object&gt;();

    for (let i = 0; i &lt; totalItems; i++) {
      let pendingItem = pendingFetchItems[i];
      let identifier = pendingItem.identifier;
      identifiers[i] = identifier;
      optionsMap.set(identifier, pendingItem.options);
      seeking[identifier.id as string] = pendingItem;
    }

    if (shouldCoalesce) {
      // TODO: Improve records =&gt; snapshots =&gt; records =&gt; snapshots
      //
      // We want to provide records to all store methods and snapshots to all
      // adapter methods. To make sure we&#x27;re doing that we&#x27;re providing an array
      // of snapshots to adapter.groupRecordsForFindMany(), which in turn will
      // return grouped snapshots instead of grouped records.
      //
      // But since the _findMany() finder is a store method we need to get the
      // records from the grouped snapshots even though the _findMany() finder
      // will once again convert the records to snapshots for adapter.findMany()
      let snapshots = new Array&lt;Snapshot&gt;(totalItems);
      for (let i = 0; i &lt; totalItems; i++) {
        let options = optionsMap.get(identifiers[i]);
        snapshots[i] = new Snapshot(options, identifiers[i], this._store);
      }

      let groups: Snapshot[][] = adapter.groupRecordsForFindMany(this, snapshots);

      for (let i = 0, l = groups.length; i &lt; l; i++) {
        this._processCoalescedGroup(seeking, groups[i], adapter, optionsMap, modelName);
      }
    } else {
      for (let i = 0; i &lt; totalItems; i++) {
        this._fetchRecord(pendingFetchItems[i]);
      }
    }
  }

  flushAllPendingFetches() {
    if (this.isDestroyed) {
      return;
    }

    this._pendingFetch.forEach(this._flushPendingFetchForType, this);
    this._pendingFetch.clear();
  }

  destroy() {
    this.isDestroyed = true;
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
