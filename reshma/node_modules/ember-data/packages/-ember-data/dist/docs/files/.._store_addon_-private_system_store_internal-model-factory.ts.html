<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../store/addon/-private/system/store/internal-model-factory.ts - The ember-data API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The ember-data API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v3.16.0-alpha.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/@ember-data.html">@ember-data</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/AdapterPopulatedRecordArray.html">AdapterPopulatedRecordArray</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Ember.HTMLBars.helpers.html">Ember.HTMLBars.helpers</a></li>
                                <li><a href="../classes/Ember.Inflector.html">Ember.Inflector</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentityMap.html">IdentityMap</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InternalModelMap.html">InternalModelMap</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/MinimumSerializerInterface.html">MinimumSerializerInterface</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordArrayManager.html">RecordArrayManager</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/Reference.html">Reference</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/RootState.html">RootState</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data.html">@ember-data</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_record-data.html">@ember-data/record-data</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../store/addon/-private/system/store/internal-model-factory.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { assert, warn } from &#x27;@ember/debug&#x27;;
import { IdentifierCache, identifierCacheFor } from &#x27;../../identifiers/cache&#x27;;
import InternalModel from &#x27;../model/internal-model&#x27;;
import IdentityMap from &#x27;../identity-map&#x27;;
import { StableRecordIdentifier } from &#x27;../../ts-interfaces/identifier&#x27;;
import InternalModelMap from &#x27;../internal-model-map&#x27;;
import { isNone } from &#x27;@ember/utils&#x27;;
import { IDENTIFIERS } from &#x27;@ember-data/canary-features&#x27;;
import { Record } from &#x27;../../ts-interfaces/record&#x27;;
import {
  ResourceIdentifierObject,
  ExistingResourceObject,
  NewResourceIdentifierObject,
} from &#x27;../../ts-interfaces/ember-data-json-api&#x27;;
import { DEBUG } from &#x27;@glimmer/env&#x27;;
import CoreStore from &#x27;../core-store&#x27;;
import constructResource from &#x27;../../utils/construct-resource&#x27;;

/**
  @module @ember-data/store
*/

const FactoryCache = new WeakMap&lt;CoreStore, InternalModelFactory&gt;();
type NewResourceInfo = { type: string; id: string | null };

const RecordCache = new WeakMap&lt;Record, StableRecordIdentifier&gt;();

export function peekRecordIdentifier(record: any): StableRecordIdentifier | undefined {
  return RecordCache.get(record);
}

export function recordIdentifierFor(record: Record): StableRecordIdentifier {
  let identifier = RecordCache.get(record);

  if (DEBUG &amp;&amp; identifier === undefined) {
    throw new Error(&#x60;${record} is not a record instantiated by @ember-data/store&#x60;);
  }

  return identifier as StableRecordIdentifier;
}

export function setRecordIdentifier(record: Record, identifier: StableRecordIdentifier): void {
  if (DEBUG &amp;&amp; RecordCache.has(record)) {
    throw new Error(&#x60;${record} was already assigned an identifier&#x60;);
  }

  /*
  It would be nice to do a reverse check here that an identifier has not
  previously been assigned a record; however, unload + rematerialization
  prevents us from having a great way of doing so when CustomRecordClasses
  don&#x27;t necessarily give us access to a &#x60;isDestroyed&#x60; for dematerialized
  instance.
  */

  RecordCache.set(record, identifier);
}

export function internalModelFactoryFor(store: CoreStore): InternalModelFactory {
  let factory = FactoryCache.get(store);

  if (factory === undefined) {
    factory = new InternalModelFactory(store);
    FactoryCache.set(store, factory);
  }

  return factory;
}

/**
 * The InternalModelFactory handles the lifecyle of
 * instantiating, caching, and destroying InternalModel
 * instances.
 *
 * @internal
 */
export default class InternalModelFactory {
  private _identityMap: IdentityMap;
  private _newlyCreated: IdentityMap;
  public identifierCache: IdentifierCache;

  constructor(public store: CoreStore) {
    this.identifierCache = identifierCacheFor(store);
    this.identifierCache.__configureMerge((identifier, matchedIdentifier, resourceData) =&gt; {
      const intendedIdentifier = identifier.id === resourceData.id ? identifier : matchedIdentifier;
      const altIdentifier = identifier.id === resourceData.id ? matchedIdentifier : identifier;

      // check for duplicate InternalModel&#x27;s
      const map = this.modelMapFor(identifier.type);
      let im = map.get(intendedIdentifier.lid);
      let otherIm = map.get(altIdentifier.lid);

      // we cannot merge internalModels when both have records
      // (this may not be strictly true, we could probably swap the internalModel the record points at)
      if (im &amp;&amp; otherIm &amp;&amp; im.hasRecord &amp;&amp; otherIm.hasRecord) {
        throw new Error(
          &#x60;Failed to update the &#x27;id&#x27; for the RecordIdentifier &#x27;${identifier}&#x27; to &#x27;${resourceData.id}&#x27;, because that id is already in use by &#x27;${matchedIdentifier}&#x27;&#x60;
        );
      }

      // remove otherIm from cache
      if (otherIm) {
        map.remove(otherIm, altIdentifier.lid);
      }

      if (im === null &amp;&amp; otherIm === null) {
        // nothing more to do
        return intendedIdentifier;

        // only the other has an InternalModel
        // OR only the other has a Record
      } else if ((im === null &amp;&amp; otherIm !== null) || (im &amp;&amp; !im.hasRecord &amp;&amp; otherIm &amp;&amp; otherIm.hasRecord)) {
        if (im) {
          // TODO check if we are retained in any async relationships
          map.remove(im, intendedIdentifier.lid);
          // im.destroy();
        }
        im = otherIm;
        // TODO do we need to notify the id change?
        im._id = intendedIdentifier.id;
        map.add(im, intendedIdentifier.lid);

        // just use im
      } else {
        // otherIm.destroy();
      }

      return intendedIdentifier;
    });
    this._identityMap = new IdentityMap();
    if (!IDENTIFIERS) {
      this._newlyCreated = new IdentityMap();
    }
  }

  /**
   * Retrieve the InternalModel for a given { type, id, lid }.
   *
   * If an InternalModel does not exist, it instantiates one.
   *
   * If an InternalModel does exist bus has a scheduled destroy,
   *   the scheduled destroy will be cancelled.
   *
   * @internal
   */
  lookup(resource: ResourceIdentifierObject, data?: ExistingResourceObject): InternalModel {
    if (IDENTIFIERS &amp;&amp; data !== undefined) {
      // if we&#x27;ve been given data associated with this lookup
      // we must first give secondary-caches for LIDs the
      // opportunity to populate based on it
      this.identifierCache.getOrCreateRecordIdentifier(data);
    }

    const identifier = this.identifierCache.getOrCreateRecordIdentifier(resource);
    const internalModel = this.peek(identifier);

    if (internalModel) {
      // unloadRecord is async, if one attempts to unload + then sync push,
      //   we must ensure the unload is canceled before continuing
      //   The createRecord path will take _existingInternalModelForId()
      //   which will call &#x60;destroySync&#x60; instead for this unload + then
      //   sync createRecord scenario. Once we have true client-side
      //   delete signaling, we should never call destroySync
      if (internalModel.hasScheduledDestroy()) {
        internalModel.cancelDestroy();
      }

      return internalModel;
    }

    return this._build(identifier, false);
  }

  /**
   * Peek the InternalModel for a given { type, id, lid }.
   *
   * If an InternalModel does not exist, return &#x60;null&#x60;.
   *
   * @internal
   */
  peek(identifier: StableRecordIdentifier): InternalModel | null {
    if (IDENTIFIERS) {
      return this.modelMapFor(identifier.type).get(identifier.lid);
    } else {
      let internalModel: InternalModel | null = null;

      internalModel = this._newlyCreatedModelsFor(identifier.type).get(identifier.lid);

      if (!internalModel &amp;&amp; identifier.id) {
        internalModel = this.modelMapFor(identifier.type).get(identifier.id);
      }

      return internalModel;
    }
  }

  getByResource(resource: ResourceIdentifierObject): InternalModel {
    if (IDENTIFIERS) {
      const normalizedResource = constructResource(resource.type, resource.id, resource.lid);

      return this.lookup(normalizedResource);
    } else {
      let res = resource as { type: string; clientId?: string; id: string | null; lid?: string };
      let internalModel: InternalModel | null = null;

      if (res.clientId) {
        internalModel = this._newlyCreatedModelsFor(resource.type).get(res.clientId);
      }

      if (internalModel === null) {
        internalModel = this.lookup(resource);
      }

      return internalModel;
    }
  }

  setRecordId(type: string, id: string, lid: string) {
    const resource: NewResourceIdentifierObject = { type, id: null, lid };
    const identifier = this.identifierCache.getOrCreateRecordIdentifier(resource);
    const internalModel = this.peek(identifier);

    if (internalModel === null) {
      throw new Error(&#x60;Cannot set the id ${id} on the record ${type}:${lid} as there is no such record in the cache.&#x60;);
    }

    let oldId = internalModel.id;
    let modelName = internalModel.modelName;

    // ID absolutely can&#x27;t be missing if the oldID is empty (missing Id in response for a new record)
    assert(
      &#x60;&#x27;${modelName}&#x27; was saved to the server, but the response does not have an id and your record does not either.&#x60;,
      !(id === null &amp;&amp; oldId === null)
    );

    // ID absolutely can&#x27;t be different than oldID if oldID is not null
    // TODO this assertion and restriction may not strictly be needed in the identifiers world
    assert(
      &#x60;Cannot update the id for &#x27;${modelName}:${lid}&#x27; from &#x27;${oldId}&#x27; to &#x27;${id}&#x27;.&#x60;,
      !(oldId !== null &amp;&amp; id !== oldId)
    );

    // ID can be null if oldID is not null (altered ID in response for a record)
    // however, this is more than likely a developer error.
    if (oldId !== null &amp;&amp; id === null) {
      warn(
        &#x60;Your ${modelName} record was saved to the server, but the response does not have an id.&#x60;,
        !(oldId !== null &amp;&amp; id === null)
      );
      return;
    }

    let existingInternalModel = this.peekById(modelName, id);

    assert(
      &#x60;&#x27;${modelName}&#x27; was saved to the server, but the response returned the new id &#x27;${id}&#x27;, which has already been used with another record.&#x27;&#x60;,
      isNone(existingInternalModel) || existingInternalModel === internalModel
    );

    if (!IDENTIFIERS) {
      this.modelMapFor(type).set(id, internalModel);
      this._newlyCreatedModelsFor(type).remove(internalModel, lid);
    }

    if (identifier.id === null) {
      this.identifierCache.updateRecordIdentifier(identifier, { type, id });
    }

    internalModel.setId(id);
  }

  peekById(type: string, id: string): InternalModel | null {
    const identifier = this.identifierCache.peekRecordIdentifier({ type, id });

    let internalModel: InternalModel | null;

    if (IDENTIFIERS) {
      internalModel = identifier ? this.modelMapFor(type).get(identifier.lid) : null;
    } else {
      internalModel = this.modelMapFor(type).get(id);
    }

    if (internalModel &amp;&amp; internalModel.hasScheduledDestroy()) {
      // unloadRecord is async, if one attempts to unload + then sync create,
      //   we must ensure the unload is complete before starting the create
      //   The push path will take this.lookup()
      //   which will call &#x60;cancelDestroy&#x60; instead for this unload + then
      //   sync push scenario. Once we have true client-side
      //   delete signaling, we should never call destroySync
      internalModel.destroySync();
      internalModel = null;
    }
    return internalModel;
  }

  build(newResourceInfo: NewResourceInfo): InternalModel {
    return this._build(newResourceInfo, true);
  }

  _build(resource: StableRecordIdentifier, isCreate: false): InternalModel;
  _build(resource: NewResourceInfo, isCreate: true): InternalModel;
  _build(resource: StableRecordIdentifier | NewResourceInfo, isCreate: boolean = false): InternalModel {
    if (isCreate === true &amp;&amp; resource.id) {
      let existingInternalModel = this.peekById(resource.type, resource.id);

      assert(
        &#x60;The id ${resource.id} has already been used with another &#x27;${resource.type}&#x27; record.&#x60;,
        !existingInternalModel
      );
    }

    const { identifierCache } = this;
    let identifier: StableRecordIdentifier;

    if (isCreate === true) {
      identifier = identifierCache.createIdentifierForNewRecord(resource);
    } else {
      identifier = resource as StableRecordIdentifier;
    }

    // lookupFactory should really return an object that creates
    // instances with the injections applied
    let internalModel = new InternalModel(this.store, identifier);

    if (IDENTIFIERS) {
      this.modelMapFor(resource.type).add(internalModel, identifier.lid);
    } else {
      if (isCreate === true) {
        this._newlyCreatedModelsFor(identifier.type).add(internalModel, identifier.lid);
      }
      // TODO @runspired really?!
      this.modelMapFor(resource.type).add(internalModel, identifier.id);
    }

    return internalModel;
  }

  remove(internalModel: InternalModel): void {
    let recordMap = this.modelMapFor(internalModel.modelName);
    let clientId = internalModel.identifier.lid;

    if (IDENTIFIERS) {
      recordMap.remove(internalModel, clientId);
    } else {
      if (internalModel.id) {
        recordMap.remove(internalModel, internalModel.id);
      }
      this._newlyCreatedModelsFor(internalModel.modelName).remove(internalModel, clientId);
    }

    const { identifier } = internalModel;
    this.identifierCache.forgetRecordIdentifier(identifier);
  }

  modelMapFor(type: string): InternalModelMap {
    return this._identityMap.retrieve(type);
  }

  _newlyCreatedModelsFor(type: string): InternalModelMap {
    return this._newlyCreated.retrieve(type);
  }

  clear(type?: string) {
    if (type === undefined) {
      this._identityMap.clear();
    } else {
      this.modelMapFor(type).clear();
    }
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
